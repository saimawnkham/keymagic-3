# KeyMagic Binary Keyboard File (KM2) Format Documentation

## Overview

The KeyMagic Binary Keyboard File (KM2) format is a compiled binary representation of KeyMagic keyboard layouts. KM2 files are generated by compiling KeyMagic Script (KMS) files and are optimized for fast loading and efficient runtime processing by the KeyMagic input method engine.

## File Structure

The KM2 file consists of four main sections written sequentially:

1. **File Header** - Version info and section counts
2. **String/Variable Section** - Variable definitions and string literals
3. **Info Section** - Metadata about the keyboard layout
4. **Rules Section** - Binary-encoded keyboard mapping rules

## Data Types and Endianness

- **Endianness**: All multi-byte values are stored in **little-endian** format
- **Strings**: UTF-16LE encoding (2 bytes per character)
- **Booleans**: Single byte values (0x00 = false, 0x01 = true)
- **Integers**: 16-bit (short) and 32-bit (int) signed integers
- **File Size**: Typically ranges from a few KB to several hundred KB

## File Header

The file header is 16 bytes and contains essential file information:

```c
struct KM2Header {
    char magicCode[4];           // File signature: "KMKL" (0x4B4D4B4C)
    uint8_t majorVersion;        // Major version number (currently 1)
    uint8_t minorVersion;        // Minor version number (currently 5)
    uint16_t stringCount;        // Number of strings/variables
    uint16_t infoCount;          // Number of info entries
    uint16_t ruleCount;          // Number of mapping rules
    LayoutOptions options;       // Layout behavior flags (5 bytes)
};
```

### Layout Options Structure

```c
struct LayoutOptions {
    bool trackCaps;    // Consider CAPSLOCK key state in pattern matching
    bool autoBksp;     // Enable smart backspace behavior
    bool eat;          // Consume keys that don't match any rule
    bool posBased;     // Layout based on US keyboard physical positions
    bool rightAlt;     // Treat CTRL+ALT combination as Right Alt (v1.5+)
};
```

### Version History

| Version | Features |
|---------|----------|
| 1.3 | Basic format without info section |
| 1.4 | Added info section for metadata |
| 1.5 | Added rightAlt option in layout options |

## String/Variable Section

This section stores all variables and string constants referenced in the keyboard rules.

### Structure

Each string entry follows this format:

```
+--------+--------+--------+--------+
| Length |      UTF-16LE String     |
| 2bytes |     (Length * 2 bytes)   |
+--------+-----------------------+--+
```

- **Length** (2 bytes): Number of Unicode characters (not bytes)
- **Data** (variable): UTF-16LE encoded string data

### Variable References

Variables can contain references to other variables using the `opVARIABLE` opcode (0x00F1) followed by a 1-based index.

### Example

```
String: "ကခဂ" (3 Myanmar characters)
Binary: 0x0003 0x1000 0x1001 0x1002
        |      |              |
        Length UTF-16LE chars  |
```

## Info Section

The info section stores metadata about the keyboard layout. Available since version 1.4.

### Structure

Each info entry has this format:

```
+--------+--------+--------+--------+
|   ID   | Length |      Data       |
| 4bytes | 2bytes | (Length bytes)  |
+--------+--------+-----------------+
```

### Standard Info IDs

| ID (4 bytes) | ASCII | Description | Data Format |
|--------------|-------|-------------|-------------|
| 0x6E616D65 | 'name' | Keyboard display name | UTF-16LE string |
| 0x64657363 | 'desc' | Keyboard description | UTF-16LE string |
| 0x666F6E74 | 'font' | Recommended font family | UTF-16LE string |
| 0x69636F6E | 'icon' | Keyboard icon | BMP image data |
| 0x68746B79 | 'htky' | Hotkey combination | Binary hotkey data |

### Icon Data Format

Icon data is stored as a complete BMP file including headers. The icon should be 16x16 or 32x32 pixels for optimal display.

### Hotkey Data Format

Hotkey data encodes key combinations:
- **Modifier flags** (1 byte): Ctrl, Alt, Shift combinations
- **Virtual key code** (1 byte): Target key code

## Rules Section

The rules section contains the compiled keyboard mapping rules encoded as binary opcodes.

### Rule Structure

Each rule consists of:

```
+--------+--------+--------+--------+
|LHS Len |LHS Data|RHS Len |RHS Data|
|2 bytes |Variable|2 bytes |Variable|
+--------+--------+--------+--------+
```

- **LHS (Left-Hand Side)**: Input pattern to match
- **RHS (Right-Hand Side)**: Output pattern to generate

### Binary Opcodes

All opcodes are 2-byte values (16-bit integers):

| Opcode | Name | Description | Parameters |
|--------|------|-------------|------------|
| 0x00F0 | opSTRING | String literal | Length + UTF-16LE string |
| 0x00F1 | opVARIABLE | Variable reference | 1-based variable index |
| 0x00F2 | opREFERENCE | Back-reference | Segment number (1-based) |
| 0x00F3 | opPREDEFINED | Virtual key code | VK_* constant value |
| 0x00F4 | opMODIFIER | Key modifier | Modifier flags |
| 0x00F5 | opANYOF | Match any char in set | Variable index |
| 0x00F6 | opAND | Logical AND | Combines conditions |
| 0x00F7 | opNANYOF | Match char NOT in set | Variable index |
| 0x00F8 | opANY | Match any character | None |
| 0x00F9 | opSWITCH | State switch | State string |

### Rule Encoding Examples

#### Simple String Mapping
KMS: `"ka" => "က"`

Binary encoding:
```
LHS: opSTRING, 0x0002, 'k', 'a'
RHS: opSTRING, 0x0001, 'က'
```

#### Variable with Wildcard
KMS: `$consonants[*] => $vowels[$1]`

Binary encoding:
```
LHS: opANYOF, variable_index_consonants
RHS: opVARIABLE, variable_index_vowels, opREFERENCE, 0x0001
```

#### Virtual Key Combination
KMS: `<VK_SHIFT & VK_KEY_A> => "အ"`

Binary encoding:
```
LHS: opPREDEFINED, VK_SHIFT, opAND, opPREDEFINED, VK_KEY_A
RHS: opSTRING, 0x0001, 'အ'
```

#### State Switch
KMS: `< VK_CFLEX > => ('zg_key')`

Binary encoding:
```
LHS: opPREDEFINED, VK_CFLEX
RHS: opSWITCH, "zg_key"
```

## File Loading Process

The KeyMagic engine loads KM2 files using this sequence:

1. **Header Validation**
   - Verify magic code "KMKL"
   - Check version compatibility
   - Read section counts

2. **String/Variable Loading**
   - Read `stringCount` entries
   - Store in indexed array for rule references
   - Resolve variable cross-references

3. **Info Loading** (version 1.4+)
   - Read `infoCount` metadata entries
   - Store keyboard name, description, etc.

4. **Rule Loading**
   - Read `ruleCount` binary rule entries
   - Convert opcodes to internal rule representation
   - Sort rules by matching priority

5. **Optimization**
   - Build lookup tables for fast pattern matching
   - Prepare state transition tables

## File Creation Process

KM2 files are created by the KeyMagic parser:

1. **Parse KMS file** using Flex/Bison parser
2. **Build symbol table** of variables and strings
3. **Compile rules** to binary opcode sequences
4. **Generate header** with counts and options
5. **Write binary file** in sequential section order

## Performance Considerations

The KM2 format is optimized for:

- **Fast loading**: Binary format loads faster than parsing text
- **Memory efficiency**: Compact representation reduces memory usage
- **Runtime speed**: Pre-compiled opcodes enable fast pattern matching
- **Rule priority**: Rules are stored in matching priority order

## Debugging and Analysis

To analyze KM2 files:

1. **Hex editors**: View raw binary structure
2. **KeyMagic tools**: Use built-in debugging functions
3. **Custom parsers**: Write tools using the format specification

## Error Handling

Common file format errors:

- **Invalid magic code**: File is not a KM2 file
- **Unsupported version**: File version too new or old
- **Truncated file**: File size doesn't match expected sections
- **Invalid opcodes**: Unknown opcode values in rules
- **Circular references**: Variables referencing themselves

## Security Considerations

- **File validation**: Always validate header and section boundaries
- **Buffer overflows**: Check string lengths before reading
- **Resource limits**: Limit maximum file size and rule counts
- **Malformed data**: Handle invalid Unicode sequences gracefully

## Compatibility

The KM2 format maintains backward compatibility:

- Version 1.5 readers can load 1.3 and 1.4 files
- Missing sections are treated as empty
- Unknown options default to safe values
- Invalid data is rejected with error messages